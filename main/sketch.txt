#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp_err.h"

#define SPI_MOSI 11 // Mapped onto SDO pin of the PIC18F --- 11 -> RC6 pin of PIC18F
#define SPI_MISO 13 // Mapped onto SDI pin of the PIC18F --- 13 -> RC5 pin of PIC18F
#define SPI_SCLK 12 // Mapped onto SCK pin of the PIC18F --- 12 -> RC4 pin of PIC18F
#define SPI_CS 10   // Mapped onto SS pin of the PIC18F  --- 10 -> RA5 pin of PIC18F

spi_device_handle_t spi;

void spi_master_init()
{
    spi_bus_config_t buscfg = {
        .mosi_io_num = SPI_MOSI,
        .miso_io_num = SPI_MISO,
        .sclk_io_num = SPI_SCLK,

        .quadwp_io_num = -1,
        .quadhd_io_num = -1};

    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 1000000, // 1MHz SPI clock
        .mode = 0,                 // SPI mode 0 (CPOL=0, CPHA=0)
        .spics_io_num = SPI_CS,
        .queue_size = 1};

    // Initialize SPI bus
    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK)
    {
        printf("Failed to initialize SPI bus: %d\n", ret);
    }

    // Attach device to SPI bus
    ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
    if (ret != ESP_OK)
    {
        printf("Failed to add SPI device: %d\n", ret);
    }
}

void spi_send_receive(uint8_t *tx_data, size_t length, uint8_t *rx_data)
{
    spi_transaction_t trans = {
        .length = length * 8, // Length in bits
        .tx_buffer = tx_data, // Data to send
        .rx_buffer = rx_data  // Buffer to receive data
    };

    // Transmit the data
    esp_err_t ret = spi_device_transmit(spi, &trans);
    if (ret != ESP_OK)
    {
        printf("SPI transmission failed: %d\n", ret);
    }
}

uint8_t *spi_bytes_exchange(uint8_t *tx_data, size_t length)
{
    if (length == 0 || length > 256) // Beperkingen instellen
    {
        printf("SPI Exchange: Ongeldige lengte (%d)\n", (int)length);
        return NULL;
    }

    uint8_t *rx_data = (uint8_t *)malloc(length); // Dynamisch buffer aanmaken
    if (!rx_data)
    {
        printf("SPI Exchange: Geheugenallocatie mislukt\n");
        return NULL;
    }
    memset(rx_data, 0, length); // Buffer leegmaken

    spi_send_receive(tx_data, length, rx_data);

    return rx_data; // Caller moet `free(rx_data)` uitvoeren na gebruik!
}

void app_main()
{
    spi_master_init();

    while (1)
    {
        uint8_t tx_buffer[] = {0xAA}; // Test data (0b10101010)
        size_t length = sizeof(tx_buffer);

        // gpio_set_level(SPI_CS, 0); // CS low
        uint8_t *rx_buffer = spi_bytes_exchange(tx_buffer, length);
        // gpio_set_level(SPI_CS, 1); //
        if (rx_buffer)
        {
            printf("Received data: ");
            for (size_t i = 0; i < length; i++)
            {
                printf("%02X ", rx_buffer[i]);
            }
            printf("\n");

            free(rx_buffer); // Vermijd geheugenlekken!
        }

        vTaskDelay(pdMS_TO_TICKS(1000)); // Delay 1s
    }
}



_____________________________________
PIC18F

#include "mcc_generated_files/system/system.h"
#include "xc.h"
//#include <stdio.h>  // Include standard I/O for printf

// Function to send a character via UART
//void UART_WriteChar(char data) {
//    while (!UART1_IsTxReady());  // Wait until UART is ready
//    UART1_Write(data);           // Send the character
//}

// Custom putch function to make printf work with UART
//void putch(char data) {
//    UART_WriteChar(data);  // Send the character to UART
//}

void main(void) {
    // Initialize the system and hardware
    SYSTEM_Initialize();
    
    // Initialize SPI as a slave
    SPI1_Initialize();

    // Print a startup message via UART
    printf("SPI Slave Initialised. Waiting for data...\r\n");

    uint8_t receivedData = 0;  // Variable to store received SPI data

    while (1) {
        // Check if SPI has received new data
        if (SPI1_IsRxReady()) {
            receivedData = SPI1_ByteExchange(0x1B);  // Receive data, send dummy byte

            // Print the received SPI data
            printf("Received Data: %d (0x%02X)\r\n", receivedData, receivedData);
        }
    }
}




_____________________________________

 /*
 * MAIN Generated Driver File
 * 
 * @file main.c
 * 
 * @defgroup main MAIN
 * 
 * @brief This is the generated driver implementation file for the MAIN driver.
 *
 * @version MAIN Driver Version 1.0.2
 *
 * @version Package Version: 3.1.2
*/

/*
Â© [2025] Microchip Technology Inc. and its subsidiaries.

    Subject to your compliance with these terms, you may use Microchip 
    software and any derivatives exclusively with Microchip products. 
    You are responsible for complying with 3rd party license terms  
    applicable to your use of 3rd party software (including open source  
    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
    THIS SOFTWARE.
*/

#include "mcc_generated_files/system/system.h"
#include "xc.h"
//#include <stdio.h>  // Include standard I/O for printf

// Function to send a character via UART
//void UART_WriteChar(char data) {
//    while (!UART1_IsTxReady());  // Wait until UART is ready
//    UART1_Write(data);           // Send the character
//}

// Custom putch function to make printf work with UART
//void putch(char data) {
//    UART_WriteChar(data);  // Send the character to UART
//}

void main(void) {
    // Initialize the system and hardware
    SYSTEM_Initialize();
    
    // Enable the Global High Interrupts 
    INTERRUPT_GlobalInterruptEnable();      
    
    // Initialize SPI as a slave
    SPI1_Initialize();
    
    SPI1_Open(1);
//    SPI1CON2 &= ~(1 << 2); // Zet de SSET-bit (bit 2) op 0

    

    // Print a startup message via UART
    printf("SPI Slave Initialised. Waiting for data...\r\n");

    uint8_t receivedData = 0;  // Variable to store received SPI data
    
//    receivedData = SPI1_ByteExchange(0xAA);  // Receive data, send dummy byte
//        
//       
//        // Print the received SPI data
//        printf("Received Data: %d (0x%02X)\r\n", receivedData, receivedData);
    
    while (1) {
        printf("in the while loop\n");
        // Check if SPI has received new data
//          if (SPI1_IsRxReady()) {
//            receivedData = SPI1_ByteExchange(0x1B);  // Receive data, send dummy byte
//
//            // Print the received SPI data
//            printf("Received Data: %d (0x%02X)\r\n", receivedData, receivedData);
//        }
        if (PORTAbits.RA5 == 0) { // RA5 is de SS pin
            printf("SS is LOW, SPI transaction should start.\n");
        } else {
            printf("SS is HIGH, waiting for transaction...\n");
        }
        receivedData = SPI1_ByteExchange(0xAA);  // Receive data, send dummy byte
        
        //uint8_t receivedData = SPI1_ByteRead();
       
        // Print the received SPI data
        printf("Received Data: %d (0x%02X)\r\n", receivedData, receivedData);
    }
}


_____________________________________

void SPI1_Receive_ISR(void)
{
    printf("SPI1_Receive_ISR triggered!\n");
    
	if(spi1_descriptor.bytesToReceive > (size_t)0)
	{
		//Read the receive buffer register
		*spi1_descriptor.receiveBuffer = SPI1RXB;
		spi1_descriptor.receiveBuffer++;
		spi1_descriptor.bytesToReceive = spi1_descriptor.bytesToReceive - 1U;
	}
	else
    {
        //In case of operation for Byte Write
        //To clear the interrupt flag, perform a dummy read
        (void)SPI1RXB;
    }

	if((size_t)0 == spi1_descriptor.bytesToReceive)
	{
        //If no more bytes to receive disable the interrupts
		PIE3bits.SPI1RXIE 	= 0U;
        //Check to see if more bytes are there to transmit
        //In case of Buffer Read there wont be any bytes to transmit
        //It should set it the status to SPI_IDLE
        if((size_t)0 == spi1_descriptor.bytesToTransmit)
        {
	    	spi1_descriptor.status = SPI_IDLE;	
    	}
		else
		{
			//Do nothing
		}
		if (SPI1_RxCompleteCallback != NULL)
        {
        	SPI1_RxCompleteCallback();
        }
        else
        {
        	// No callback exists
        }
	}
	else
	{
		//Do nothing
	}
}

void SPI1_Transmit_ISR(void)
{
    printf("SPI1_Transmit_ISR triggered!\n");
    
	if(spi1_descriptor.bytesToTransmit > (size_t)0)
	{
        //Transmit the data on transmit buffer register
		SPI1TXB = *spi1_descriptor.transmitBuffer;
		spi1_descriptor.transmitBuffer++;
		spi1_descriptor.bytesToTransmit = spi1_descriptor.bytesToTransmit - 1U;
	}
	else
	{
		//Do nothing
	}
	
	//The execution comes here to check if there is no more bytes to transmit
	//This condition is true in case of last byte to be transmitted
	if((size_t)0 == spi1_descriptor.bytesToTransmit)
	{
		PIE3bits.SPI1TXIE 	= 0U;
        //Check to see if more bytes are there to receive
        //In case of Buffer Write there wont be any bytes to receive
        //It should set it the status to SPI_IDLE
        if((size_t)0 == spi1_descriptor.bytesToReceive)
		{
			spi1_descriptor.status = SPI_IDLE;
		}
		else
		{
			//Do nothing
		}
		if (SPI1_TxCompleteCallback != NULL)
    	{
        	SPI1_TxCompleteCallback();
    	}
    	else
    	{
        	// No callback exists
    	}
	}
}


_____________________________________

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp_err.h"

#define SPI_MOSI 11 // Mapped onto SDO pin of the PIC18F --- 11 -> RC6 pin of PIC18F
#define SPI_MISO 14 // Mapped onto SDI pin of the PIC18F --- 14 -> RC5 pin of PIC18F
#define SPI_SCLK 12 // Mapped onto SCK pin of the PIC18F --- 12 -> RC4 pin of PIC18F
#define SPI_CS 9    // Mapped onto SS pin of the PIC18F  --- 9 -> RA6 pin of PIC18F

spi_device_handle_t spi;

void spi_master_init()
{
    spi_bus_config_t buscfg = {
        .mosi_io_num = SPI_MOSI,
        .miso_io_num = SPI_MISO,
        .sclk_io_num = SPI_SCLK,

        .quadwp_io_num = -1,
        .quadhd_io_num = -1};

    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 1000000, // 1MHz SPI clock
        .mode = 1,
        .spics_io_num = SPI_CS,
        .queue_size = 1};

    // Initialize SPI bus
    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK)
    {
        printf("Failed to initialize SPI bus: %d\n", ret);
    }

    // Attach device to SPI bus
    ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
    if (ret != ESP_OK)
    {
        printf("Failed to add SPI device: %d\n", ret);
    }
}

void spi_send_receive(uint8_t *tx_data, size_t length, uint8_t *rx_data)
{
    spi_transaction_t trans = {
        .length = length * 8, // Length in bits
        .tx_buffer = tx_data, // Data to send
        .rx_buffer = rx_data  // Buffer to receive data
    };

    // Transmit the data
    esp_err_t ret = spi_device_transmit(spi, &trans);
    if (ret != ESP_OK)
    {
        printf("SPI transmission failed: %d\n", ret);
    }
}

uint8_t *spi_bytes_exchange(uint8_t *tx_data, size_t length)
{
    if (length == 0 || length > 256) // Beperkingen instellen
    {
        printf("SPI Exchange: Ongeldige lengte (%d)\n", (int)length);
        return NULL;
    }

    uint8_t *rx_data = (uint8_t *)malloc(length); // Dynamisch buffer aanmaken
    if (!rx_data)
    {
        printf("SPI Exchange: Geheugenallocatie mislukt\n");
        return NULL;
    }
    memset(rx_data, 0, length); // Buffer leegmaken

    spi_send_receive(tx_data, length, rx_data);

    return rx_data; // Caller moet `free(rx_data)` uitvoeren
}

void app_main()
{
    spi_master_init();
    // gpio_set_direction(SPI_CS, GPIO_MODE_OUTPUT);

    while (1)
    {
        // printf("Setting SS LOW\n");
        // gpio_reset_pin(SPI_CS);
        // gpio_set_direction(SPI_CS, GPIO_MODE_OUTPUT);
        // gpio_set_level(SPI_CS, 0);      // SS laag, slave geactiveerd
        // vTaskDelay(pdMS_TO_TICKS(500)); // 500ms delay
        // printf("SS pin state after setting LOW: %d\n", gpio_get_level(SPI_CS));

        uint8_t tx_buffer[] = {0xAA}; // Test data (0b10101010)
        size_t length = sizeof(tx_buffer);
        uint8_t *rx_buffer = spi_bytes_exchange(tx_buffer, length);
        // printf("Setting SS HIGH\n");
        // gpio_set_level(SPI_CS, 1);     // SS hoog, slave gedeactiveerd
        // vTaskDelay(pdMS_TO_TICKS(10)); // 500ms delay
        // printf("SS pin state after setting HIGH: %d\n", gpio_get_level(SPI_CS));
        // vTaskDelay(pdMS_TO_TICKS(100)); // 100ms delay
        // printf("SS pin state after setting HIGH: %d\n", gpio_get_level(SPI_CS));

        if (rx_buffer)
        {
            printf("Received data: ");
            for (size_t i = 0; i < length; i++)
            {
                printf("%02X ", rx_buffer[i]);
            }
            printf("\n");

            free(rx_buffer); // Vermijd geheugenlekken!
        }

        vTaskDelay(pdMS_TO_TICKS(1000)); // Delay 1s
    }
}

_____________________________________

#include "mcc_generated_files/system/system.h"
#include "xc.h"

void main(void) {
    // Initialize the system and hardware
    SYSTEM_Initialize();
    
    // Enable the Global High Interrupts 
    INTERRUPT_GlobalInterruptEnable();      
    
    // Initialize SPI as a slave
    SPI1_Initialize();
    
    SPI1_Open(1);
//    SPI1CON2 &= ~(1 << 2); // Zet de SSET-bit (bit 2) op 0

    

    // Print a startup message via UART
    printf("SPI Slave Initialised. Waiting for data...\r\n");

    uint8_t receivedData = 0;  // Variable to store received SPI data
    
    
    while (1) {
//        printf("in the while loop\n");
//        // Check if SPI has received new data
//        // if (SPI1_IsRxReady()) {
//        // receivedData = SPI1_ByteExchange(0x1B);  // Receive data, send dummy byte
//        //
//        //// Print the received SPI data
//        // printf("Received Data: %d (0x%02X)\r\n", receivedData, receivedData);
//        // }
//        if (PORTAbits.RA5 == 0) { // RA5 is de SS pin
//            printf("SS is LOW, SPI transaction should start.\n");
//        } else {
//            printf("SS is HIGH, waiting for transaction...\n");
//        }
//        
//        
//        receivedData = SPI1_ByteExchange(0xAA);  // Receive data, send dummy byte
//        
//        
//        
//        //uint8_t receivedData = SPI1_ByteRead();
//       
//        // Print the received SPI data
//        printf("Received Data: %d (0x%02X)\r\n", receivedData, receivedData);
    }
}

_____________________________________

#define SPI_MOSI 11 // Connected to SDI pin of PIC18F (RC5)
#define SPI_MISO 13 // Connected to SDO pin of PIC18F (RC6)
#define SPI_SCLK 12 // Connected to SCK pin of PIC18F (RC4)
#define SPI_CS 10   // Connected to SS pin of PIC18F (RA6)

















// void spi_master_init()
// {
//     spi_bus_config_t buscfg = {
//         .mosi_io_num = SPI_MOSI,
//         .miso_io_num = SPI_MISO,
//         .sclk_io_num = SPI_SCLK,

//         .quadwp_io_num = -1,
//         .quadhd_io_num = -1};

//     spi_device_interface_config_t devcfg = {
//         .clock_speed_hz = 100000, // 1MHz SPI clock
//         .mode = 1,
//         .spics_io_num = SPI_CS,
//         .queue_size = 1};

//     // Initialize SPI bus
//     esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to initialize SPI bus: %d\n", ret);
//     }

//     // Attach device to SPI bus
//     ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to add SPI device: %d\n", ret);
//     }
// }



_____________________________________

Working single byte code + current status bufferExchange

// /*
// * MAIN Generated Driver File
// * 
// * @file main.c
// * 
// * @defgroup main MAIN
// * 
// * @brief This is the generated driver implementation file for the MAIN driver.
// *
// * @version MAIN Driver Version 1.0.2
// *
// * @version Package Version: 3.1.2
//*/
//
///*
//Â© [2025] Microchip Technology Inc. and its subsidiaries.
//
//    Subject to your compliance with these terms, you may use Microchip 
//    software and any derivatives exclusively with Microchip products. 
//    You are responsible for complying with 3rd party license terms  
//    applicable to your use of 3rd party software (including open source  
//    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
//    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
//    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
//    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
//    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
//    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
//    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
//    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
//    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
//    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
//    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
//    THIS SOFTWARE.
//*/
//
//
//
#include "mcc_generated_files/system/system.h"
#include "xc.h"



#define BUFFER_SIZE 10  // Define buffer size

void main(void) {
    // Initialize the system and SPI
    SYSTEM_Initialize();
    
    // Enable global interrupts
    INTERRUPT_GlobalInterruptEnable();

    // Open SPI in slave mode
    SPI1_Open(1);

    // Print startup message
//    printf("SPI Slave Initialized. Waiting for data...\r\n");

//    uint8_t receivedData[BUFFER_SIZE] = {0};  // Buffer for received data
//    uint8_t responseData[BUFFER_SIZE] = {0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22, 0x33, 0x44, 0x55}; // Example response buffer
//
    while (1) {
//       if (SPI1_IsRxReady()) {  
//            // Exchange full buffer instead of looping
//            SPI1_BufferExchange(responseData, BUFFER_SIZE);
//            
//            // Print received data in formatted output
//            printf("SPI Exchange: Received Data: { ");
//            for (int i = 0; i < BUFFER_SIZE; i++) {
//                printf("0x%02X%s", receivedData[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
//            }
//            printf("}\n");
//        }
    }
}




//void main(void) {
//    // Initialize the system and hardware
//    SYSTEM_Initialize();
//    
//    // Enable the Global High Interrupts 
//    INTERRUPT_GlobalInterruptEnable();
//    
//    // Enable the Peripheral Interrupts
//    // INTERRUPT_PeripheralInterruptEnable();
//    
////    // Initialize SPI as a slave
////    SPI1_Initialize();
//    
//    // Open SPI with the correct configuration for Mode 1
//    // Make sure this configuration matches ESP32's Mode 1 (CPOL=0, CPHA=1)
//    SPI1_Open(1);  // Using configuration index 0
//    
//    // Print a startup message via UART
//    printf("SPI Slave Initialized. Waiting for data...\r\n");
//    
//    uint8_t receivedData = 0;
//    uint8_t responseData = 0xBB;  // Fixed response value to send back to master
//    
//    while (1) {
//        // Simple polling approach - check if data is available
//        if (SPI1_IsTxReady()) {
//            // Exchange byte - receive data and send response
//            receivedData = SPI1_ByteExchange(responseData);
//            
//            // Print after transaction is complete
//            printf("SPI Exchange: Received 0x%02X, Sent 0x%02X\r\n", receivedData, responseData);
//        }
////        receivedData = SPI1_ByteExchange(responseData);
//            
////        // Print after transaction is complete
////        printf("SPI Exchange: Received 0x%02X, Sent 0x%02X\r\n", receivedData, responseData);
//    }
//}


_____________________________________

Working single byte exchange ESP  + current status buffer exchange

#include <stdio.h>
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
#define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
#define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
#define SPI_CS 21   // Connected to SS pin of PIC18F (RA6)

#define BUFFER_SIZE 10 // Example buffer size

spi_device_handle_t spi;

void spi_master_init()
{
    // SPI bus configuration
    spi_bus_config_t buscfg = {
        .mosi_io_num = SPI_MOSI,
        .miso_io_num = SPI_MISO,
        .sclk_io_num = SPI_SCLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1};

    // SPI device configuration
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 100000, // 1MHz SPI clock
        .mode = 3,                // Mode 1: CPOL=0, CPHA=1
        .spics_io_num = SPI_CS,
        .queue_size = 1};

    // Initialize SPI bus
    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK)
    {
        printf("Failed to initialize SPI bus: %d\n", ret);
        return;
    }

    // Attach device to SPI bus
    ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
    if (ret != ESP_OK)
    {
        printf("Failed to add SPI device: %d\n", ret);
        return;
    }

    printf("SPI master initialized successfully\n");
}

void app_main()
{
    // Initialize SPI master
    spi_master_init();
    printf("SPI Master initialized. Starting transactions...\n");

    // Create data buffers for transmitting and receiving
    uint8_t tx_data[BUFFER_SIZE] = {0x09, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    uint8_t rx_data[BUFFER_SIZE]; // Buffer to store received data

    // Initialize the tx_data buffer with some values
    // for (int i = 0; i < BUFFER_SIZE; i++)
    // {
    //     tx_data[i] = i; // Just an example, filling with 0, 1, 2, ...
    // }

    // Wait for a moment to ensure the slave is ready
    vTaskDelay(pdMS_TO_TICKS(1000));

    while (1)
    {
        // Prepare transaction
        spi_transaction_t trans = {
            .length = BUFFER_SIZE * 8, // Length in bits (BUFFER_SIZE bytes)
            .tx_buffer = tx_data,
            .rx_buffer = rx_data};

        esp_err_t ret = spi_device_transmit(spi, &trans);

        if (ret == ESP_OK)
        {
            printf("SPI Exchange: Sent %d bytes, Received %d bytes\n", BUFFER_SIZE, BUFFER_SIZE);
            printf("Received Data: { ");
            for (int i = 0; i < BUFFER_SIZE; i++)
            {
                printf("0x%02X%s", rx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
            }
            printf("}\n");
        }
        else
        {
            printf("SPI transaction failed: %d\n", ret);
        }

        // Wait before next transaction
        vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay
    }
}

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>
// #include "driver/spi_master.h"
// #include "driver/gpio.h"
// #include "esp_err.h"

// #define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
// #define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
// #define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
// #define SPI_CS 21   // Connected to SS pin of PIC18F (RA6)

// spi_device_handle_t spi;

// void spi_master_init()
// {
//     spi_bus_config_t buscfg = {
//         .mosi_io_num = SPI_MOSI,
//         .miso_io_num = SPI_MISO,
//         .sclk_io_num = SPI_SCLK,

//         .quadwp_io_num = -1,
//         .quadhd_io_num = -1};

//     spi_device_interface_config_t devcfg = {
//         .clock_speed_hz = 100000, // 1MHz SPI clock
//         .mode = 1,
//         .spics_io_num = SPI_CS,
//         .queue_size = 1};

//     // Initialize SPI bus
//     esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to initialize SPI bus: %d\n", ret);
//     }

//     // Attach device to SPI bus
//     ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to add SPI device: %d\n", ret);
//     }
// }

// void spi_send_receive(uint8_t *tx_data, size_t length, uint8_t *rx_data)
// {
//     spi_transaction_t trans = {
//         .length = length * 8, // Length in bits
//         .tx_buffer = tx_data, // Data to send
//         .rx_buffer = rx_data  // Buffer to receive data
//     };

//     // Transmit the data
//     esp_err_t ret = spi_device_transmit(spi, &trans);
//     if (ret != ESP_OK)
//     {
//         printf("SPI transmission failed: %d\n", ret);
//     }
// }

// uint8_t *spi_bytes_exchange(uint8_t *tx_data, size_t length)
// {
//     if (length == 0 || length > 256) // Beperkingen instellen
//     {
//         printf("SPI Exchange: Ongeldige lengte (%d)\n", (int)length);
//         return NULL;
//     }

//     uint8_t *rx_data = (uint8_t *)malloc(length); // Dynamisch buffer aanmaken
//     if (!rx_data)
//     {
//         printf("SPI Exchange: Geheugenallocatie mislukt\n");
//         return NULL;
//     }
//     memset(rx_data, 0, length); // Buffer leegmaken

//     spi_send_receive(tx_data, length, rx_data);

//     return rx_data; // Caller moet `free(rx_data)` uitvoeren
// }

// void app_main()
// {
//     spi_master_init();

//     uint8_t tx_data = 0xAA;
//     uint8_t rx_data = 0;

//     vTaskDelay(pdMS_TO_TICKS(1000));

//     while (1)
//     {
//         // Prepare transaction
//         spi_transaction_t trans = {
//             .length = 8, // 8 bits (1 byte)
//             .tx_buffer = &tx_data,
//             .rx_buffer = &rx_data};

//         esp_err_t ret = spi_device_transmit(spi, &trans);

//         if (ret == ESP_OK)
//         {
//             printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//         }
//         else
//         {
//             printf("SPI transaction failed: %d\n", ret);
//         }

//         // Wait before next transaction
//         vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay
//     }
// }




_____________________________________


// /*
// * MAIN Generated Driver File
// * 
// * @file main.c
// * 
// * @defgroup main MAIN
// * 
// * @brief This is the generated driver implementation file for the MAIN driver.
// *
// * @version MAIN Driver Version 1.0.2
// *
// * @version Package Version: 3.1.2
//*/
//
///*
//Â© [2025] Microchip Technology Inc. and its subsidiaries.
//
//    Subject to your compliance with these terms, you may use Microchip 
//    software and any derivatives exclusively with Microchip products. 
//    You are responsible for complying with 3rd party license terms  
//    applicable to your use of 3rd party software (including open source  
//    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
//    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
//    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
//    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
//    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
//    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
//    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
//    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
//    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
//    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
//    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
//    THIS SOFTWARE.
//*/
//
//
//
//#include "mcc_generated_files/system/system.h"
//#include "xc.h"
//
//
//
//#define BUFFER_SIZE 10  // Define buffer size
//
//void main(void) {
//    // Initialize the system and SPI
//    SYSTEM_Initialize();
//    
//    // Enable global interrupts
//    INTERRUPT_GlobalInterruptEnable();
//
//    // Open SPI in slave mode
//    SPI1_Open(1);
//
//    // Print startup message
////    printf("SPI Slave Initialized. Waiting for data...\r\n");
//
////    uint8_t receivedData[BUFFER_SIZE] = {0};  // Buffer for received data
////    uint8_t responseData[BUFFER_SIZE] = {0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22, 0x33, 0x44, 0x55}; // Example response buffer
////
//    while (1) {
////       if (SPI1_IsRxReady()) {  
////            // Exchange full buffer instead of looping
////            SPI1_BufferExchange(responseData, BUFFER_SIZE);
////            
////            // Print received data in formatted output
////            printf("SPI Exchange: Received Data: { ");
////            for (int i = 0; i < BUFFER_SIZE; i++) {
////                printf("0x%02X%s", receivedData[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
////            }
////            printf("}\n");
////        }
//    }
//}


#include "mcc_generated_files/system/system.h"
#include "xc.h"
#include <string.h>
#include <stdio.h>

#define BUFFER_SIZE 10

void main(void) {
    // Initialize the system and SPI
    SYSTEM_Initialize();
    
    // Enable global interrupts
    INTERRUPT_GlobalInterruptEnable();

    // Open SPI in slave mode
    SPI1_Open(1);

    // Buffers
    uint8_t receivedData[BUFFER_SIZE] = {0};  // Buffer for received data
    uint8_t responseData[BUFFER_SIZE] = {0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22, 0x33, 0x44, 0x55}; // Example response buffer

    while (1) {
        if(SPI1_IsTxReady()){
            SPI1TXB = responseData[0];
            // Copy the response data to the received buffer so it's transmitted out
            memcpy(receivedData, responseData, BUFFER_SIZE);

            // Do the SPI buffer exchange
            SPI1_BufferExchange(receivedData, BUFFER_SIZE);

            // Print received data for debugging
            printf("SPI Exchange: Received Data: { ");
            for (int i = 0; i < BUFFER_SIZE; i++) {
                printf("0x%02X%s", receivedData[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
            }
            printf(" }\r\n");
        }
    }   
}




//void main(void) {
//    // Initialize the system and hardware
//    SYSTEM_Initialize();
//    
//    // Enable the Global High Interrupts 
//    INTERRUPT_GlobalInterruptEnable();
//    
//    // Enable the Peripheral Interrupts
//    // INTERRUPT_PeripheralInterruptEnable();
//    
////    // Initialize SPI as a slave
////    SPI1_Initialize();
//    
//    // Open SPI with the correct configuration for Mode 1
//    // Make sure this configuration matches ESP32's Mode 1 (CPOL=0, CPHA=1)
//    SPI1_Open(1);  // Using configuration index 0
//    
//    // Print a startup message via UART
//    printf("SPI Slave Initialized. Waiting for data...\r\n");
//    
//    uint8_t receivedData = 0;
//    uint8_t responseData = 0xBB;  // Fixed response value to send back to master
//    
//    while (1) {
//        // Simple polling approach - check if data is available
//        if (SPI1_IsTxReady()) {
//            // Exchange byte - receive data and send response
//            receivedData = SPI1_ByteExchange(responseData);
//            
//            // Print after transaction is complete
//            printf("SPI Exchange: Received 0x%02X, Sent 0x%02X\r\n", receivedData, responseData);
//        }
////        receivedData = SPI1_ByteExchange(responseData);
//            
////        // Print after transaction is complete
////        printf("SPI Exchange: Received 0x%02X, Sent 0x%02X\r\n", receivedData, responseData);
//    }
//}



_____________________________________

#include <stdio.h>
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
#define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
#define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
#define SPI_CS 21   // Connected to SS pin of PIC18F (RA6)

#define BUFFER_SIZE 10 // Example buffer size

spi_device_handle_t spi;

void spi_master_init()
{
    // SPI bus configuration
    spi_bus_config_t buscfg = {
        .mosi_io_num = SPI_MOSI,
        .miso_io_num = SPI_MISO,
        .sclk_io_num = SPI_SCLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1};

    // SPI device configuration
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 50000, // 1MHz SPI clock
        .mode = 1,                 // Mode 1: CPOL=0, CPHA=1
        .spics_io_num = SPI_CS,
        .queue_size = 1};

    // Initialize SPI bus
    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK)
    {
        printf("Failed to initialize SPI bus: %d\n", ret);
        return;
    }

    // Attach device to SPI bus
    ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
    if (ret != ESP_OK)
    {
        printf("Failed to add SPI device: %d\n", ret);
        return;
    }

    printf("SPI master initialized successfully\n");
}

void app_main()
{
    // Initialize SPI master
    spi_master_init();
    printf("SPI Master initialized. Starting transactions...\n");

    // Create data buffers for transmitting and receiving
    uint8_t tx_data[BUFFER_SIZE] = {0x09, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    uint8_t rx_data[BUFFER_SIZE]; // Buffer to store received data

    // Initialize the tx_data buffer with some values
    // for (int i = 0; i < BUFFER_SIZE; i++)
    // {
    //     tx_data[i] = i; // Just an example, filling with 0, 1, 2, ...
    // }

    // Wait for a moment to ensure the slave is ready
    vTaskDelay(pdMS_TO_TICKS(1000));

    while (1)
    {
        // Prepare transaction
        spi_transaction_t trans = {
            .length = BUFFER_SIZE * 8, // Length in bits (BUFFER_SIZE bytes)
            .tx_buffer = tx_data,
            .rx_buffer = rx_data};

        esp_err_t ret = spi_device_transmit(spi, &trans);

        if (ret == ESP_OK)
        {
            printf("SPI Exchange: Sent %d bytes, Received %d bytes\n", BUFFER_SIZE, BUFFER_SIZE);
            printf("Received Data: { ");
            for (int i = 0; i < BUFFER_SIZE; i++)
            {
                printf("0x%02X%s", rx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
            }
            printf("}\n");
        }
        else
        {
            printf("SPI transaction failed: %d\n", ret);
        }

        // Wait before next transaction
        vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay
    }
}

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>
// #include "driver/spi_master.h"
// #include "driver/gpio.h"
// #include "esp_err.h"

// #define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
// #define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
// #define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
// #define SPI_CS 21   // Connected to SS pin of PIC18F (RA6)

// spi_device_handle_t spi;

// void spi_master_init()
// {
//     spi_bus_config_t buscfg = {
//         .mosi_io_num = SPI_MOSI,
//         .miso_io_num = SPI_MISO,
//         .sclk_io_num = SPI_SCLK,

//         .quadwp_io_num = -1,
//         .quadhd_io_num = -1};

//     spi_device_interface_config_t devcfg = {
//         .clock_speed_hz = 100000, // 1MHz SPI clock
//         .mode = 1,
//         .spics_io_num = SPI_CS,
//         .queue_size = 1};

//     // Initialize SPI bus
//     esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to initialize SPI bus: %d\n", ret);
//     }

//     // Attach device to SPI bus
//     ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to add SPI device: %d\n", ret);
//     }
// }

// void spi_send_receive(uint8_t *tx_data, size_t length, uint8_t *rx_data)
// {
//     spi_transaction_t trans = {
//         .length = length * 8, // Length in bits
//         .tx_buffer = tx_data, // Data to send
//         .rx_buffer = rx_data  // Buffer to receive data
//     };

//     // Transmit the data
//     esp_err_t ret = spi_device_transmit(spi, &trans);
//     if (ret != ESP_OK)
//     {
//         printf("SPI transmission failed: %d\n", ret);
//     }
// }

// uint8_t *spi_bytes_exchange(uint8_t *tx_data, size_t length)
// {
//     if (length == 0 || length > 256) // Beperkingen instellen
//     {
//         printf("SPI Exchange: Ongeldige lengte (%d)\n", (int)length);
//         return NULL;
//     }

//     uint8_t *rx_data = (uint8_t *)malloc(length); // Dynamisch buffer aanmaken
//     if (!rx_data)
//     {
//         printf("SPI Exchange: Geheugenallocatie mislukt\n");
//         return NULL;
//     }
//     memset(rx_data, 0, length); // Buffer leegmaken

//     spi_send_receive(tx_data, length, rx_data);

//     return rx_data; // Caller moet `free(rx_data)` uitvoeren
// }

// void app_main()
// {
//     spi_master_init();

//     uint8_t tx_data = 0xAA;
//     uint8_t rx_data = 0;

//     vTaskDelay(pdMS_TO_TICKS(1000));

//     while (1)
//     {
//         // Prepare transaction
//         spi_transaction_t trans = {
//             .length = 8, // 8 bits (1 byte)
//             .tx_buffer = &tx_data,
//             .rx_buffer = &rx_data};

//         esp_err_t ret = spi_device_transmit(spi, &trans);

//         if (ret == ESP_OK)
//         {
//             printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//         }
//         else
//         {
//             printf("SPI transaction failed: %d\n", ret);
//         }

//         // Wait before next transaction
//         vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay
//     }
// }


_____________________________________

#include "mcc_generated_files/system/system.h"
#include "xc.h"
#include <string.h>
#include <stdio.h>

#define BUFFER_SIZE 10

void main(void) {
    // Initialize the system and SPI
    SYSTEM_Initialize();
    
    // Enable global interrupts
    INTERRUPT_GlobalInterruptEnable();

    // Open SPI in slave mode
    SPI1_Open(1);

    // Buffers
    uint8_t receivedData[BUFFER_SIZE] = {0};  // Buffer for received data
    uint8_t responseData[BUFFER_SIZE] = {0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22, 0x33, 0x44, 0x55}; // Example response buffer

    while (1) {
        if(SPI1_IsTxReady()){
            SPI1TXB = responseData[0];
            // Copy the response data to the received buffer so it's transmitted out
            memcpy(receivedData, responseData, BUFFER_SIZE);

            // Do the SPI buffer exchange
            SPI1_BufferExchange(receivedData, BUFFER_SIZE);

            // Print received data for debugging
            printf("SPI Exchange: Received Data: { ");
            for (int i = 0; i < BUFFER_SIZE; i++) {
                printf("0x%02X%s", receivedData[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
            }
            printf(" }\r\n");
        }
    }   
}
















_____________________________________




Files for the working multiple buffer exchange stream








/**
  * SPI1 Generated Driver File
  *
  * @file spi1.c
  *
  * @ingroup spi1
  *
  * @brief This file contains the driver code for the SPI1 module.
  *
  * @version SPI1 Driver Version v3.1.1.
*/

/*
Â© [2025] Microchip Technology Inc. and its subsidiaries.

    Subject to your compliance with these terms, you may use Microchip 
    software and any derivatives exclusively with Microchip products. 
    You are responsible for complying with 3rd party license terms  
    applicable to your use of 3rd party software (including open source  
    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
    THIS SOFTWARE.
*/

#include <xc.h>
#include "../spi_interface.h"
#include "../spi1.h"
#include "../spi_interrupt_types.h"

/**
 * @ingroup spi1
 * @struct SPI_INTERFACE SPI1
 * @brief Defines an object for SPI_INTERFACE functions.
 */ 
 
const struct SPI_INTERFACE SPI1_Client = {
    .Initialize = SPI1_Initialize,
    .Deinitialize = SPI1_Deinitialize,
    .Open = SPI1_Open,
    .Close = SPI1_Close,
    .BufferExchange = SPI1_BufferExchange,
    .BufferWrite = SPI1_BufferWrite,
    .BufferRead = SPI1_BufferRead,	
    .ByteExchange = SPI1_ByteExchange,
    .ByteWrite = SPI1_ByteWrite,
    .ByteRead = SPI1_ByteRead,
    .IsTxReady = SPI1_IsTxReady,
    .IsRxReady = SPI1_IsRxReady,
    .RxCompleteCallbackRegister = SPI1_RxCompleteCallbackRegister,
    .TxCompleteCallbackRegister = SPI1_TxCompleteCallbackRegister
};

static void (*SPI1_RxCompleteCallback)(void);
static void (*SPI1_TxCompleteCallback)(void);

static spi_descriptor_t spi1_descriptor = {
    .transmitBuffer 	= NULL,
    .receiveBuffer 	= NULL,
    .bytesToTransmit   	= 0,
    .bytesToReceive   	= 0,
    .status 		= SPI_RESET
};

//con0 == SPI1CON0, con1 == SPI1CON1, con2 == SPI1CON2, baud == SPI1BAUD, clksel == SPI1CLKSEL
static const spi_configuration_t spi1_configuration[] = {   
    { 0x0, 0x0, 0x4, 0x3f, 0x00 },
    { 0x0, 0x4, 0x0, 0x0, 0x0 }
};

void SPI1_Initialize(void)
{
    //Disable the interrupts
    PIE3bits.SPI1IE 		= 0U;
    PIE3bits.SPI1TXIE 	= 0U;
    PIE3bits.SPI1RXIE 	= 0U;
	
	//Registers set to power-on-reset value
    SPI1CON0 = 0x0;
    SPI1CON1 = 0x4;
    SPI1CON2 = 0x0;
    SPI1BAUD = 0x0;
    SPI1CLK = 0x0;      
	
	SPI1STATUSbits.CLRBF = 1U;
	SPI1_RxCompleteCallbackRegister(NULL);
	SPI1_TxCompleteCallbackRegister(NULL);	
	spi1_descriptor.status = SPI_RESET;
}

void SPI1_Deinitialize(void)
{
    SPI1CON0bits.EN = 0U;
	spi1_descriptor.status = SPI_RESET;
}

bool SPI1_Open(uint8_t spiConfigIndex)
{
	bool returnValue = false; 
	if(false == SPI1CON0bits.EN)
	{
		spi1_descriptor.status = SPI_IDLE;
        SPI1CON0 = spi1_configuration[spiConfigIndex].con0;
        SPI1CON1 = spi1_configuration[spiConfigIndex].con1;
	    SPI1CON2 = spi1_configuration[spiConfigIndex].con2 & ~(_SPI1CON2_SPI1RXR_MASK) & ~(_SPI1CON2_SPI1TXR_MASK);
        SPI1BAUD = spi1_configuration[spiConfigIndex].baud;        
        SPI1CLK = spi1_configuration[spiConfigIndex].clksel;        
		
        // Assuming SCK is on RC4
        TRISCbits.TRISC4 = 1;  // Clock is input

        // Assuming SS is on RA6
        TRISAbits.TRISA6 = 1;  // SS is input

        // Assuming SDO is on RC5 (example, check your actual pinout!)
        TRISCbits.TRISC6 = 0;  // SDO is output

        // Assuming SDI is on RC6 (example)
        TRISCbits.TRISC5 = 1;  // SDI is input
        
//        TRISCbits.TRISC4 = 1;
		PIE3bits.SPI1IE 	= 1U;
        SPI1CON0bits.EN = 1U;
		returnValue = true;
	}
	else
	{
		returnValue = false;
	}
	return returnValue;
}

void SPI1_Close(void)
{
	SPI1CON0bits.EN = 0U;
	PIE3bits.SPI1IE 		= 0U;
    PIE3bits.SPI1TXIE 	= 0U;
    PIE3bits.SPI1RXIE 	= 0U;
	spi1_descriptor.status = SPI_RESET;
}

void SPI1_BufferExchange(void *bufferData, size_t bufferSize)
{
	uint8_t* bufferInput = bufferData;
    
    printf("SPI Exchange spi.c: Received Data: { ");
    for (int i = 0; i < 10; i++) {
        printf("0x%02X%s", bufferInput[i], (i < 10 - 1) ? ", " : " ");
    }
    printf(" }\r\n");

	if (SPI_IDLE == spi1_descriptor.status)
    {
        SPI1STATUSbits.CLRBF = 1U;

		//Set as full duplex mode for buffer exchange operation
        SPI1CON2 = (SPI1CON2 | _SPI1CON2_SPI1RXR_MASK) | _SPI1CON2_SPI1TXR_MASK;

		//Load the spi1_descriptor
		spi1_descriptor.transmitBuffer 	= bufferInput;
		spi1_descriptor.receiveBuffer 	= bufferInput;
        spi1_descriptor.bytesToTransmit = bufferSize;
        spi1_descriptor.bytesToReceive 	= bufferSize;
        spi1_descriptor.status 			= SPI_BUSY;

        //Load the transfer count registers
		SPI1TCNTH = (uint8_t)(bufferSize>>8);
		SPI1TCNTL = (uint8_t)(bufferSize);
		
		PIE3bits.SPI1RXIE 	= 1U;
		PIE3bits.SPI1TXIE 	= 1U;
	}
	else
	{
		// No operation when module is already in use
	}
}

void SPI1_BufferWrite(void *bufferData, size_t bufferSize)
{
	uint8_t* bufferInput = bufferData;

	if (SPI_IDLE == spi1_descriptor.status)
    {
		SPI1STATUSbits.CLRBF = 1U;

		//Set as transmit only mode for buffer write operation
        SPI1CON2 = (SPI1CON2 & ~_SPI1CON2_SPI1RXR_MASK) | _SPI1CON2_SPI1TXR_MASK;
		
		//Load the spi1_descriptor
		spi1_descriptor.transmitBuffer 	= bufferInput;
		spi1_descriptor.receiveBuffer 	= NULL;
        spi1_descriptor.bytesToTransmit 	= bufferSize;
	    spi1_descriptor.bytesToReceive 	= 0U;
        spi1_descriptor.status 			= SPI_BUSY;

        //Load the transfer count registers
		SPI1TCNTH = (uint8_t)(bufferSize>>8);
		SPI1TCNTL = (uint8_t)(bufferSize);

		PIE3bits.SPI1TXIE 	= 1U;
	}
	else
	{
		// No operation when module is already in use
	}
}

void SPI1_BufferRead(void *bufferData, size_t bufferSize)
{
	uint8_t* bufferInput = bufferData;

	if (SPI_IDLE == spi1_descriptor.status)
    {
		SPI1STATUSbits.CLRBF = 1U;	

		//Set as receive only mode for buffer read operation
        SPI1CON2 = (SPI1CON2 & ~_SPI1CON2_SPI1TXR_MASK) | _SPI1CON2_SPI1RXR_MASK;
		
		//Load the spi1_descriptor
		spi1_descriptor.transmitBuffer 	= NULL;
		spi1_descriptor.receiveBuffer 	= bufferInput;
	    spi1_descriptor.bytesToTransmit 	= 0U;
        spi1_descriptor.bytesToReceive 	= bufferSize;
	    spi1_descriptor.status 			= SPI_BUSY;

		//Load the transfer count registers
		SPI1TCNTH = (uint8_t)(bufferSize>>8);
		SPI1TCNTL = (uint8_t)(bufferSize);

		PIE3bits.SPI1RXIE 	= 1U;
	}
	else
	{
		// No operation when module is already in use
	}
}

uint8_t SPI1_ByteExchange(uint8_t byteData)
{
	uint8_t returnValue = 0U;
	while(SPI_IDLE != spi1_descriptor.status)
    {
        // Waiting for the current operation to finish
    }

	SPI1STATUSbits.CLRBF = 1U;
	
	//Set as full duplex mode
	SPI1CON2 = SPI1CON2 | _SPI1CON2_SPI1RXR_MASK | _SPI1CON2_SPI1TXR_MASK;	
	
	//Load the spi1_descriptor
	spi1_descriptor.transmitBuffer 		= &byteData;
	spi1_descriptor.receiveBuffer 		= &byteData;
    spi1_descriptor.bytesToTransmit 	= 1;
	spi1_descriptor.bytesToReceive 		= 1;
	spi1_descriptor.status 				= SPI_BUSY;

    //Load the transfer count registers
	SPI1TCNTH = 0U;
	SPI1TCNTL = 1U;

	PIE3bits.SPI1RXIE 	= 1U;
	PIE3bits.SPI1TXIE 	= 1U;
	
	//Wait on transmit complete
	while(SPI_BUSY == spi1_descriptor.status){
	};
	
	return byteData;
}

void SPI1_ByteWrite(uint8_t byteData)
{
	if(SPI_IDLE == spi1_descriptor.status)
	{
		//Set as full duplex mode
		SPI1CON2 = SPI1CON2 | _SPI1CON2_SPI1RXR_MASK | _SPI1CON2_SPI1TXR_MASK;
        
		//Load the transfer count registers
		SPI1TCNTH = 0;
		SPI1TCNTL = 1;

		SPI1TXB = byteData;
	}
	else
	{
		//Do nothing
	}
}

uint8_t SPI1_ByteRead(void)
{
	uint8_t returnValue = 0x00U;
	if(SPI_IDLE == spi1_descriptor.status)
	{		
		//Set as full duplex mode
		SPI1CON2 = SPI1CON2 | _SPI1CON2_SPI1RXR_MASK | _SPI1CON2_SPI1TXR_MASK;
		
		//Store received data from receive buffer register 
		returnValue = SPI1RXB;
	}
	else
	{
		returnValue = 0x00U;
	}
	return returnValue;
}

bool SPI1_IsTxReady(void)
{
	bool returnValue = false;
    if (SPI_IDLE == spi1_descriptor.status)
    {
        returnValue = true;
    }
    else 
    {
        returnValue = false;
    }
    return returnValue;
}

bool SPI1_IsRxReady(void)
{
	bool returnValue = false;
    if((spi1_descriptor.status == SPI_IDLE) && (1U == PIR3bits.SPI1RXIF))
    {
        returnValue = true;
    }
    else 
    {
        returnValue = false;
    }
    return returnValue;
}

void SPI1_RxCompleteCallbackRegister(void (*rxCompleteCallbackHandler)(void))
{
	SPI1_RxCompleteCallback = rxCompleteCallbackHandler;
}

void SPI1_TxCompleteCallbackRegister(void (*txCompleteCallbackHandler)(void))
{
	SPI1_TxCompleteCallback = txCompleteCallbackHandler;
}

void SPI1_Receive_ISR(void)
{
	if(spi1_descriptor.bytesToReceive > (size_t)0)
	{
		//Read the receive buffer register
		*spi1_descriptor.receiveBuffer = SPI1RXB;
		spi1_descriptor.receiveBuffer++;
		spi1_descriptor.bytesToReceive = spi1_descriptor.bytesToReceive - 1U;
	}
	else
    {
        //In case of operation for Byte Write
        //To clear the interrupt flag, perform a dummy read
        (void)SPI1RXB;
    }

	if((size_t)0 == spi1_descriptor.bytesToReceive)
	{
        //If no more bytes to receive disable the interrupts
		PIE3bits.SPI1RXIE 	= 0U;
        //Check to see if more bytes are there to transmit
        //In case of Buffer Read there wont be any bytes to transmit
        //It should set it the status to SPI_IDLE
        if((size_t)0 == spi1_descriptor.bytesToTransmit)
        {
	    	spi1_descriptor.status = SPI_IDLE;	
    	}
		else
		{
			//Do nothing
		}
		if (SPI1_RxCompleteCallback != NULL)
        {
        	SPI1_RxCompleteCallback();
        }
        else
        {
        	// No callback exists
        }
	}
	else
	{
		//Do nothing
	}
}

void SPI1_Transmit_ISR(void)
{
	if(spi1_descriptor.bytesToTransmit > (size_t)0)
	{
        //Transmit the data on transmit buffer register
		SPI1TXB = *spi1_descriptor.transmitBuffer;
		spi1_descriptor.transmitBuffer++;
		spi1_descriptor.bytesToTransmit = spi1_descriptor.bytesToTransmit - 1U;
	}
	else
	{
		//Do nothing
	}
	
	//The execution comes here to check if there is no more bytes to transmit
	//This condition is true in case of last byte to be transmitted
	if((size_t)0 == spi1_descriptor.bytesToTransmit)
	{
		PIE3bits.SPI1TXIE 	= 0U;
        //Check to see if more bytes are there to receive
        //In case of Buffer Write there wont be any bytes to receive
        //It should set it the status to SPI_IDLE
        if((size_t)0 == spi1_descriptor.bytesToReceive)
		{
			spi1_descriptor.status = SPI_IDLE;
		}
		else
		{
			//Do nothing
		}
		if (SPI1_TxCompleteCallback != NULL)
    	{
        	SPI1_TxCompleteCallback();
    	}
    	else
    	{
        	// No callback exists
    	}
	}
}
void SPI1_ISR(void)
{
	//This ISR will be for reporting errors
}




// /*
// * MAIN Generated Driver File
// * 
// * @file main.c
// * 
// * @defgroup main MAIN
// * 
// * @brief This is the generated driver implementation file for the MAIN driver.
// *
// * @version MAIN Driver Version 1.0.2
// *
// * @version Package Version: 3.1.2
//*/
//
///*
//Â© [2025] Microchip Technology Inc. and its subsidiaries.
//
//    Subject to your compliance with these terms, you may use Microchip 
//    software and any derivatives exclusively with Microchip products. 
//    You are responsible for complying with 3rd party license terms  
//    applicable to your use of 3rd party software (including open source  
//    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
//    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
//    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
//    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
//    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
//    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
//    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
//    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
//    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
//    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
//    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
//    THIS SOFTWARE.
//*/
//
//
//
//#include "mcc_generated_files/system/system.h"
//#include "xc.h"
//
//
//
//#define BUFFER_SIZE 10  // Define buffer size
//
//void main(void) {
//    // Initialize the system and SPI
//    SYSTEM_Initialize();
//    
//    // Enable global interrupts
//    INTERRUPT_GlobalInterruptEnable();
//
//    // Open SPI in slave mode
//    SPI1_Open(1);
//
//    // Print startup message
////    printf("SPI Slave Initialized. Waiting for data...\r\n");
//
////    uint8_t receivedData[BUFFER_SIZE] = {0};  // Buffer for received data
////    uint8_t responseData[BUFFER_SIZE] = {0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22, 0x33, 0x44, 0x55}; // Example response buffer
////
//    while (1) {
////       if (SPI1_IsRxReady()) {  
////            // Exchange full buffer instead of looping
////            SPI1_BufferExchange(responseData, BUFFER_SIZE);
////            
////            // Print received data in formatted output
////            printf("SPI Exchange: Received Data: { ");
////            for (int i = 0; i < BUFFER_SIZE; i++) {
////                printf("0x%02X%s", receivedData[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
////            }
////            printf("}\n");
////        }
//    }
//}


#include "mcc_generated_files/system/system.h"
#include "xc.h"
#include <string.h>
#include <stdio.h>

#define BUFFER_SIZE 10
#define SPI_CS_PORT PORTAbits.RA6

void main(void) {
    // Initialize the system and SPI
    SYSTEM_Initialize();
    
    // Enable global interrupts
    INTERRUPT_GlobalInterruptEnable();

    // Open SPI in slave mode
    SPI1_Open(1);

    // Buffers
    uint8_t receivedData[BUFFER_SIZE] = {0};  // Buffer for received data
    uint8_t responseData[BUFFER_SIZE] = {0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x11, 0x22, 0x33, 0x44, 0x55}; // Example response buffer 
    

    while (1) {
        // Check for SS fault
        if (SPI1CON2bits.SSFLT == 1) {
            printf("SS fault: transaction ended unexpectedly\r\n");
            SPI1CON2bits.SSFLT = 0; // Clear the fault
        }
        
        // Check if SPI is ready for transmission
        if(SPI1_IsTxReady()) {
           //SPI1TXB = 0x00;  // Clear the Tx buffer before loading new data
           
           //SPI1STATUSbits.CLRBF = 1U;
            
//            // Load the next byte to transmit
//            SPI1TXB = responseData[responseIndex];
//            responseIndex++;
//
//            // If all bytes have been transmitted, reset the index
//            if (responseIndex >= BUFFER_SIZE) {
//                responseIndex = 0;
//            }

            // Copy the response data to the received buffer so it's transmitted out
            memcpy(receivedData, responseData, BUFFER_SIZE);

            // Do the SPI buffer exchange
            SPI1_BufferExchange(receivedData, BUFFER_SIZE);

            // Print received data for debugging
            printf("SPI Exchange: Received Data: { ");
            for (int i = 0; i < BUFFER_SIZE; i++) {
                printf("0x%02X%s", receivedData[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
            }
            printf(" }\r\n");

        }
    }
}





//void main(void) {
//    // Initialize the system and hardware
//    SYSTEM_Initialize();
//    
//    // Enable the Global High Interrupts 
//    INTERRUPT_GlobalInterruptEnable();
//    
//    // Enable the Peripheral Interrupts
//    // INTERRUPT_PeripheralInterruptEnable();
//    
////    // Initialize SPI as a slave
////    SPI1_Initialize();
//    
//    // Open SPI with the correct configuration for Mode 1
//    // Make sure this configuration matches ESP32's Mode 1 (CPOL=0, CPHA=1)
//    SPI1_Open(1);  // Using configuration index 0
//    
//    // Print a startup message via UART
//    printf("SPI Slave Initialized. Waiting for data...\r\n");
//    
//    uint8_t receivedData = 0;
//    uint8_t responseData = 0xBB;  // Fixed response value to send back to master
//    
//    while (1) {
//        // Simple polling approach - check if data is available
//        if (SPI1_IsTxReady()) {
//            // Exchange byte - receive data and send response
//            receivedData = SPI1_ByteExchange(responseData);
//            
//            // Print after transaction is complete
//            printf("SPI Exchange: Received 0x%02X, Sent 0x%02X\r\n", receivedData, responseData);
//        }
////        receivedData = SPI1_ByteExchange(responseData);
//            
////        // Print after transaction is complete
////        printf("SPI Exchange: Received 0x%02X, Sent 0x%02X\r\n", receivedData, responseData);
//    }
//}


#include <stdio.h>
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
#define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
#define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
#define SPI_CS 48   // Connected to SS pin of PIC18F (RA6)

#define BUFFER_SIZE 10 // Example buffer size

spi_device_handle_t spi;

void spi_master_init()
{
    // SPI bus configuration
    spi_bus_config_t buscfg = {
        .mosi_io_num = SPI_MOSI,
        .miso_io_num = SPI_MISO,
        .sclk_io_num = SPI_SCLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1};

    // SPI device configuration
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 100000, // 1MHz SPI clock
        .mode = 1,                // Mode 1: CPOL=0, CPHA=1
        .spics_io_num = SPI_CS,
        .queue_size = 1};

    // Initialize SPI bus
    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK)
    {
        printf("Failed to initialize SPI bus: %d\n", ret);
        return;
    }

    // Attach device to SPI bus
    ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
    if (ret != ESP_OK)
    {
        printf("Failed to add SPI device: %d\n", ret);
        return;
    }

    printf("SPI master initialized successfully\n");
}

void app_main()
{
    // Initialize SPI master
    spi_master_init();
    printf("SPI Master initialized. Starting transactions...\n");

    // Create data buffers for transmitting and receiving
    uint8_t tx_data[BUFFER_SIZE] = {0x09, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    uint8_t rx_data[BUFFER_SIZE]; // Buffer to store received data

    // Initialize the tx_data buffer with some values
    // for (int i = 0; i < BUFFER_SIZE; i++)
    // {
    //     tx_data[i] = i; // Just an example, filling with 0, 1, 2, ...
    // }

    // Wait for a moment to ensure the slave is ready
    vTaskDelay(pdMS_TO_TICKS(1000));

    // // Prepare transaction
    // spi_transaction_t trans = {
    //     .length = BUFFER_SIZE * 8, // Length in bits (BUFFER_SIZE bytes)
    //     .tx_buffer = tx_data,
    //     .rx_buffer = rx_data};

    // printf("Setting SS HIGH\n");
    // // gpio_reset_pin(SPI_CS);
    // // gpio_set_direction(SPI_CS, GPIO_MODE_OUTPUT);
    // // gpio_set_level(SPI_CS, 0);
    // // printf("SS pin state after setting HIGH: %d\n", gpio_get_level(SPI_CS));

    // esp_err_t ret = spi_device_transmit(spi, &trans);

    // // printf("Setting SS LOW\n");
    // // gpio_set_level(SPI_CS, 1);
    // // printf("SS pin state after setting LOW: %d\n", gpio_get_level(SPI_CS));

    // if (ret == ESP_OK)
    // {
    //     printf("SPI Exchange: Sent %d bytes, Received %d bytes\n", BUFFER_SIZE, BUFFER_SIZE);
    //     printf("Send Data: { ");
    //     for (int i = 0; i < BUFFER_SIZE; i++)
    //     {
    //         printf("0x%02X%s", tx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
    //     }
    //     printf("}\n");
    //     printf("Received Data: { ");
    //     for (int i = 0; i < BUFFER_SIZE; i++)
    //     {
    //         printf("0x%02X%s", rx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
    //     }
    //     printf("}\n");
    // }
    // else
    // {
    //     printf("SPI transaction failed: %d\n", ret);
    // }

    while (1)
    {
        // Prepare transaction
        spi_transaction_t trans = {
            .length = BUFFER_SIZE * 8, // Length in bits (BUFFER_SIZE bytes)
            .tx_buffer = tx_data,
            .rx_buffer = rx_data};

        // printf("Setting SS HIGH\n");
        // // gpio_reset_pin(SPI_CS);
        // // gpio_set_direction(SPI_CS, GPIO_MODE_OUTPUT);
        gpio_set_level(SPI_CS, 1);
        printf("SS pin state after setting HIGH: %d\n", gpio_get_level(SPI_CS));

        esp_err_t ret = spi_device_transmit(spi, &trans);

        // printf("Setting SS LOW\n");
        gpio_set_level(SPI_CS, 0);
        printf("SS pin state after setting LOW: %d\n", gpio_get_level(SPI_CS));

        if (ret == ESP_OK)
        {
            printf("SPI Exchange: Sent %d bytes, Received %d bytes\n", BUFFER_SIZE, BUFFER_SIZE);
            printf("Send Data: { ");
            for (int i = 0; i < BUFFER_SIZE; i++)
            {
                printf("0x%02X%s", tx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
            }
            printf("}\n");
            printf("Received Data: { ");
            for (int i = 0; i < BUFFER_SIZE; i++)
            {
                printf("0x%02X%s", rx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
            }
            printf("}\n");
        }
        else
        {
            printf("SPI transaction failed: %d\n", ret);
        }

        // Wait before next transaction
        vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay
    }
}

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>
// #include "driver/spi_master.h"
// #include "driver/gpio.h"
// #include "esp_err.h"

// #define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
// #define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
// #define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
// #define SPI_CS 21   // Connected to SS pin of PIC18F (RA6)

// spi_device_handle_t spi;

// void spi_master_init()
// {
//     spi_bus_config_t buscfg = {
//         .mosi_io_num = SPI_MOSI,
//         .miso_io_num = SPI_MISO,
//         .sclk_io_num = SPI_SCLK,

//         .quadwp_io_num = -1,
//         .quadhd_io_num = -1};

//     spi_device_interface_config_t devcfg = {
//         .clock_speed_hz = 100000, // 1MHz SPI clock
//         .mode = 1,
//         .spics_io_num = SPI_CS,
//         .queue_size = 1};

//     // Initialize SPI bus
//     esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to initialize SPI bus: %d\n", ret);
//     }

//     // Attach device to SPI bus
//     ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to add SPI device: %d\n", ret);
//     }
// }

// void spi_send_receive(uint8_t *tx_data, size_t length, uint8_t *rx_data)
// {
//     spi_transaction_t trans = {
//         .length = length * 8, // Length in bits
//         .tx_buffer = tx_data, // Data to send
//         .rx_buffer = rx_data  // Buffer to receive data
//     };

//     // Transmit the data
//     esp_err_t ret = spi_device_transmit(spi, &trans);
//     if (ret != ESP_OK)
//     {
//         printf("SPI transmission failed: %d\n", ret);
//     }
// }

// uint8_t *spi_bytes_exchange(uint8_t *tx_data, size_t length)
// {
//     if (length == 0 || length > 256) // Beperkingen instellen
//     {
//         printf("SPI Exchange: Ongeldige lengte (%d)\n", (int)length);
//         return NULL;
//     }

//     uint8_t *rx_data = (uint8_t *)malloc(length); // Dynamisch buffer aanmaken
//     if (!rx_data)
//     {
//         printf("SPI Exchange: Geheugenallocatie mislukt\n");
//         return NULL;
//     }
//     memset(rx_data, 0, length); // Buffer leegmaken

//     spi_send_receive(tx_data, length, rx_data);

//     return rx_data; // Caller moet `free(rx_data)` uitvoeren
// }

// void app_main()
// {
//     // spi_master_init();

//     // vTaskDelay(pdMS_TO_TICKS(1000)); // Wait for slave to boot and prep

//     // // Step 1: Send 3 dummy bytes
//     // uint8_t dummy_tx = 0x00;
//     // uint8_t dummy_rx = 0;

//     // for (int i = 0; i < 3; i++)
//     // {
//     //     spi_transaction_t dummy_trans = {
//     //         .length = 8,
//     //         .tx_buffer = &dummy_tx,
//     //         .rx_buffer = &dummy_rx};

//     //     esp_err_t ret = spi_device_transmit(spi, &dummy_trans);
//     //     if (ret == ESP_OK)
//     //     {
//     //         printf("Dummy %d: Sent 0x%02X, Received 0x%02X\n", i + 1, dummy_tx, dummy_rx);
//     //     }
//     //     else
//     //     {
//     //         printf("Dummy %d failed: %d\n", i + 1, ret);
//     //     }
//     //     // vTaskDelay(pdMS_TO_TICKS(1000));
//     // }

//     // // Step 2: Send actual buffer one byte at a time
//     // uint8_t tx_buffer[] = {0xA1, 0xB2, 0xC3, 0xD4, 0xE5};
//     // uint8_t rx_byte = 0;
//     // const int buffer_len = sizeof(tx_buffer) / sizeof(tx_buffer[0]);

//     // for (int i = 0; i < buffer_len; i++)
//     // {
//     //     spi_transaction_t trans = {
//     //         .length = 8,
//     //         .tx_buffer = &tx_buffer[i],
//     //         .rx_buffer = &rx_byte};

//     //     esp_err_t ret = spi_device_transmit(spi, &trans);
//     //     if (ret == ESP_OK)
//     //     {
//     //         printf("Data %d: Sent 0x%02X, Received 0x%02X\n", i + 1, tx_buffer[i], rx_byte);
//     //     }
//     //     else
//     //     {
//     //         printf("Data %d failed: %d\n", i + 1, ret);
//     //     }
//     //     // vTaskDelay(pdMS_TO_TICKS(1000));
//     // }

//     spi_master_init();

//     uint8_t tx_data = 0xAA;
//     uint8_t tx_data_list[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
//     uint8_t rx_data = 0;

//     vTaskDelay(pdMS_TO_TICKS(1000));

//     // // Prepare transaction
//     // spi_transaction_t trans = {
//     //     .length = 8, // 8 bits (1 byte)
//     //     .tx_buffer = &tx_data,
//     //     .rx_buffer = &rx_data};

//     // esp_err_t ret = spi_device_transmit(spi, &trans);

//     // if (ret == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     // esp_err_t ret1 = spi_device_transmit(spi, &trans);

//     // if (ret1 == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     // esp_err_t ret2 = spi_device_transmit(spi, &trans);

//     // if (ret2 == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     // esp_err_t ret3 = spi_device_transmit(spi, &trans);

//     // if (ret3 == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     int count = 0;
//     tx_data = tx_data_list[count];

//     while (1)
//     {
//         // Prepare transaction
//         spi_transaction_t trans = {
//             .length = 8, // 8 bits (1 byte)
//             .tx_buffer = &tx_data,
//             .rx_buffer = &rx_data};

//         esp_err_t ret = spi_device_transmit(spi, &trans);

//         if (ret == ESP_OK)
//         {
//             printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//         }
//         else
//         {
//             printf("SPI transaction failed: %d\n", ret);
//         }

//         // Wait before next transaction
//         // vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay

//         // if (count++ > 9)
//         // {
//         //     count = 0;
//         // }
//         // count++;
//         // tx_data = tx_data_list[count];
//     }
// }







_____________________________________

 

ESP file single line send

#include <stdio.h>
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
#define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
#define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
#define SPI_CS 48   // Connected to SS pin of PIC18F (RA6)

#define BUFFER_SIZE 10 // Example buffer size

spi_device_handle_t spi;

void spi_master_init()
{
    // SPI bus configuration
    spi_bus_config_t buscfg = {
        .mosi_io_num = SPI_MOSI,
        .miso_io_num = SPI_MISO,
        .sclk_io_num = SPI_SCLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1};

    // SPI device configuration
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 100000, // 1MHz SPI clock
        .mode = 1,                // Mode 1: CPOL=0, CPHA=1
        .spics_io_num = SPI_CS,
        .queue_size = 1};

    // Initialize SPI bus
    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK)
    {
        printf("Failed to initialize SPI bus: %d\n", ret);
        return;
    }

    // Attach device to SPI bus
    ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
    if (ret != ESP_OK)
    {
        printf("Failed to add SPI device: %d\n", ret);
        return;
    }

    printf("SPI master initialized successfully\n");
}

void app_main()
{
    // Initialize SPI master
    spi_master_init();
    printf("SPI Master initialized. Starting transactions...\n");

    // Create data buffers for transmitting and receiving
    uint8_t tx_data[BUFFER_SIZE] = {0x09, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    uint8_t rx_data[BUFFER_SIZE]; // Buffer to store received data

    // Initialize the tx_data buffer with some values
    // for (int i = 0; i < BUFFER_SIZE; i++)
    // {
    //     tx_data[i] = i; // Just an example, filling with 0, 1, 2, ...
    // }

    // Wait for a moment to ensure the slave is ready
    vTaskDelay(pdMS_TO_TICKS(1000));

    // Prepare transaction
    spi_transaction_t trans = {
        .length = BUFFER_SIZE * 8, // Length in bits (BUFFER_SIZE bytes)
        .tx_buffer = tx_data,
        .rx_buffer = rx_data};

    // printf("Setting SS HIGH\n");
    // gpio_reset_pin(SPI_CS);
    // gpio_set_direction(SPI_CS, GPIO_MODE_OUTPUT);
    // gpio_set_level(SPI_CS, 0);
    // printf("SS pin state after setting HIGH: %d\n", gpio_get_level(SPI_CS));

    esp_err_t ret = spi_device_transmit(spi, &trans);

    // printf("Setting SS LOW\n");
    // gpio_set_level(SPI_CS, 1);
    // printf("SS pin state after setting LOW: %d\n", gpio_get_level(SPI_CS));

    if (ret == ESP_OK)
    {
        printf("SPI Exchange: Sent %d bytes, Received %d bytes\n", BUFFER_SIZE, BUFFER_SIZE);
        printf("Send Data: { ");
        for (int i = 0; i < BUFFER_SIZE; i++)
        {
            printf("0x%02X%s", tx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
        }
        printf("}\n");
        printf("Received Data: { ");
        for (int i = 0; i < BUFFER_SIZE; i++)
        {
            printf("0x%02X%s", rx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
        }
        printf("}\n");
    }
    else
    {
        printf("SPI transaction failed: %d\n", ret);
    }

    // while (1)
    // {
    //     // Prepare transaction
    //     spi_transaction_t trans = {
    //         .length = BUFFER_SIZE * 8, // Length in bits (BUFFER_SIZE bytes)
    //         .tx_buffer = tx_data,
    //         .rx_buffer = rx_data};

    //     // printf("Setting SS HIGH\n");
    //     // // gpio_reset_pin(SPI_CS);
    //     // // gpio_set_direction(SPI_CS, GPIO_MODE_OUTPUT);
    //     gpio_set_level(SPI_CS, 1);
    //     printf("SS pin state after setting HIGH: %d\n", gpio_get_level(SPI_CS));

    //     esp_err_t ret = spi_device_transmit(spi, &trans);

    //     // printf("Setting SS LOW\n");
    //     gpio_set_level(SPI_CS, 0);
    //     printf("SS pin state after setting LOW: %d\n", gpio_get_level(SPI_CS));

    //     if (ret == ESP_OK)
    //     {
    //         printf("SPI Exchange: Sent %d bytes, Received %d bytes\n", BUFFER_SIZE, BUFFER_SIZE);
    //         printf("Send Data: { ");
    //         for (int i = 0; i < BUFFER_SIZE; i++)
    //         {
    //             printf("0x%02X%s", tx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
    //         }
    //         printf("}\n");
    //         printf("Received Data: { ");
    //         for (int i = 0; i < BUFFER_SIZE; i++)
    //         {
    //             printf("0x%02X%s", rx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
    //         }
    //         printf("}\n");
    //     }
    //     else
    //     {
    //         printf("SPI transaction failed: %d\n", ret);
    //     }

    //     // Wait before next transaction
    //     vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay
    // }
}

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>
// #include "driver/spi_master.h"
// #include "driver/gpio.h"
// #include "esp_err.h"

// #define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
// #define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
// #define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
// #define SPI_CS 21   // Connected to SS pin of PIC18F (RA6)

// spi_device_handle_t spi;

// void spi_master_init()
// {
//     spi_bus_config_t buscfg = {
//         .mosi_io_num = SPI_MOSI,
//         .miso_io_num = SPI_MISO,
//         .sclk_io_num = SPI_SCLK,

//         .quadwp_io_num = -1,
//         .quadhd_io_num = -1};

//     spi_device_interface_config_t devcfg = {
//         .clock_speed_hz = 100000, // 1MHz SPI clock
//         .mode = 1,
//         .spics_io_num = SPI_CS,
//         .queue_size = 1};

//     // Initialize SPI bus
//     esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to initialize SPI bus: %d\n", ret);
//     }

//     // Attach device to SPI bus
//     ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to add SPI device: %d\n", ret);
//     }
// }

// void spi_send_receive(uint8_t *tx_data, size_t length, uint8_t *rx_data)
// {
//     spi_transaction_t trans = {
//         .length = length * 8, // Length in bits
//         .tx_buffer = tx_data, // Data to send
//         .rx_buffer = rx_data  // Buffer to receive data
//     };

//     // Transmit the data
//     esp_err_t ret = spi_device_transmit(spi, &trans);
//     if (ret != ESP_OK)
//     {
//         printf("SPI transmission failed: %d\n", ret);
//     }
// }

// uint8_t *spi_bytes_exchange(uint8_t *tx_data, size_t length)
// {
//     if (length == 0 || length > 256) // Beperkingen instellen
//     {
//         printf("SPI Exchange: Ongeldige lengte (%d)\n", (int)length);
//         return NULL;
//     }

//     uint8_t *rx_data = (uint8_t *)malloc(length); // Dynamisch buffer aanmaken
//     if (!rx_data)
//     {
//         printf("SPI Exchange: Geheugenallocatie mislukt\n");
//         return NULL;
//     }
//     memset(rx_data, 0, length); // Buffer leegmaken

//     spi_send_receive(tx_data, length, rx_data);

//     return rx_data; // Caller moet `free(rx_data)` uitvoeren
// }

// void app_main()
// {
//     // spi_master_init();

//     // vTaskDelay(pdMS_TO_TICKS(1000)); // Wait for slave to boot and prep

//     // // Step 1: Send 3 dummy bytes
//     // uint8_t dummy_tx = 0x00;
//     // uint8_t dummy_rx = 0;

//     // for (int i = 0; i < 3; i++)
//     // {
//     //     spi_transaction_t dummy_trans = {
//     //         .length = 8,
//     //         .tx_buffer = &dummy_tx,
//     //         .rx_buffer = &dummy_rx};

//     //     esp_err_t ret = spi_device_transmit(spi, &dummy_trans);
//     //     if (ret == ESP_OK)
//     //     {
//     //         printf("Dummy %d: Sent 0x%02X, Received 0x%02X\n", i + 1, dummy_tx, dummy_rx);
//     //     }
//     //     else
//     //     {
//     //         printf("Dummy %d failed: %d\n", i + 1, ret);
//     //     }
//     //     // vTaskDelay(pdMS_TO_TICKS(1000));
//     // }

//     // // Step 2: Send actual buffer one byte at a time
//     // uint8_t tx_buffer[] = {0xA1, 0xB2, 0xC3, 0xD4, 0xE5};
//     // uint8_t rx_byte = 0;
//     // const int buffer_len = sizeof(tx_buffer) / sizeof(tx_buffer[0]);

//     // for (int i = 0; i < buffer_len; i++)
//     // {
//     //     spi_transaction_t trans = {
//     //         .length = 8,
//     //         .tx_buffer = &tx_buffer[i],
//     //         .rx_buffer = &rx_byte};

//     //     esp_err_t ret = spi_device_transmit(spi, &trans);
//     //     if (ret == ESP_OK)
//     //     {
//     //         printf("Data %d: Sent 0x%02X, Received 0x%02X\n", i + 1, tx_buffer[i], rx_byte);
//     //     }
//     //     else
//     //     {
//     //         printf("Data %d failed: %d\n", i + 1, ret);
//     //     }
//     //     // vTaskDelay(pdMS_TO_TICKS(1000));
//     // }

//     spi_master_init();

//     uint8_t tx_data = 0xAA;
//     uint8_t tx_data_list[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
//     uint8_t rx_data = 0;

//     vTaskDelay(pdMS_TO_TICKS(1000));

//     // // Prepare transaction
//     // spi_transaction_t trans = {
//     //     .length = 8, // 8 bits (1 byte)
//     //     .tx_buffer = &tx_data,
//     //     .rx_buffer = &rx_data};

//     // esp_err_t ret = spi_device_transmit(spi, &trans);

//     // if (ret == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     // esp_err_t ret1 = spi_device_transmit(spi, &trans);

//     // if (ret1 == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     // esp_err_t ret2 = spi_device_transmit(spi, &trans);

//     // if (ret2 == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     // esp_err_t ret3 = spi_device_transmit(spi, &trans);

//     // if (ret3 == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     int count = 0;
//     tx_data = tx_data_list[count];

//     while (1)
//     {
//         // Prepare transaction
//         spi_transaction_t trans = {
//             .length = 8, // 8 bits (1 byte)
//             .tx_buffer = &tx_data,
//             .rx_buffer = &rx_data};

//         esp_err_t ret = spi_device_transmit(spi, &trans);

//         if (ret == ESP_OK)
//         {
//             printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//         }
//         else
//         {
//             printf("SPI transaction failed: %d\n", ret);
//         }

//         // Wait before next transaction
//         // vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay

//         // if (count++ > 9)
//         // {
//         //     count = 0;
//         // }
//         // count++;
//         // tx_data = tx_data_list[count];
//     }
// }



_____________________________________

#include <stdio.h>
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
#define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
#define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
#define SPI_CS 48   // Connected to SS pin of PIC18F (RA6)

#define BUFFER_SIZE 10 // Example buffer size

spi_device_handle_t spi;

void spi_master_init()
{
    // SPI bus configuration
    spi_bus_config_t buscfg = {
        .mosi_io_num = SPI_MOSI,
        .miso_io_num = SPI_MISO,
        .sclk_io_num = SPI_SCLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1};

    // SPI device configuration
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 100000, // 1MHz SPI clock
        .mode = 1,                // Mode 1: CPOL=0, CPHA=1
        .spics_io_num = SPI_CS,
        .queue_size = 1};

    // Initialize SPI bus
    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK)
    {
        printf("Failed to initialize SPI bus: %d\n", ret);
        return;
    }

    // Attach device to SPI bus
    ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
    if (ret != ESP_OK)
    {
        printf("Failed to add SPI device: %d\n", ret);
        return;
    }

    printf("SPI master initialized successfully\n");
}

void app_main()
{
    // Initialize SPI master
    spi_master_init();
    printf("SPI Master initialized. Starting transactions...\n");

    // Create data buffers for transmitting and receiving
    uint8_t tx_data[BUFFER_SIZE] = {0x09, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    uint8_t rx_data[BUFFER_SIZE]; // Buffer to store received data

    // Initialize the tx_data buffer with some values
    // for (int i = 0; i < BUFFER_SIZE; i++)
    // {
    //     tx_data[i] = i; // Just an example, filling with 0, 1, 2, ...
    // }

    // Wait for a moment to ensure the slave is ready
    vTaskDelay(pdMS_TO_TICKS(1000));

    // Prepare transaction
    spi_transaction_t trans = {
        .length = BUFFER_SIZE * 8, // Length in bits (BUFFER_SIZE bytes)
        .tx_buffer = tx_data,
        .rx_buffer = rx_data};

    // printf("Setting SS HIGH\n");
    // gpio_reset_pin(SPI_CS);
    // gpio_set_direction(SPI_CS, GPIO_MODE_OUTPUT);
    // gpio_set_level(SPI_CS, 0);
    // printf("SS pin state after setting HIGH: %d\n", gpio_get_level(SPI_CS));

    esp_err_t ret = spi_device_transmit(spi, &trans);

    // printf("Setting SS LOW\n");
    // gpio_set_level(SPI_CS, 1);
    // printf("SS pin state after setting LOW: %d\n", gpio_get_level(SPI_CS));

    if (ret == ESP_OK)
    {
        printf("SPI Exchange: Sent %d bytes, Received %d bytes\n", BUFFER_SIZE, BUFFER_SIZE);
        printf("Send Data: { ");
        for (int i = 0; i < BUFFER_SIZE; i++)
        {
            printf("0x%02X%s", tx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
        }
        printf("}\n");
        printf("Received Data: { ");
        for (int i = 0; i < BUFFER_SIZE; i++)
        {
            printf("0x%02X%s", rx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
        }
        printf("}\n");
    }
    else
    {
        printf("SPI transaction failed: %d\n", ret);
    }

    // while (1)
    // {
    //     // Prepare transaction
    //     spi_transaction_t trans = {
    //         .length = BUFFER_SIZE * 8, // Length in bits (BUFFER_SIZE bytes)
    //         .tx_buffer = tx_data,
    //         .rx_buffer = rx_data};

    //     // printf("Setting SS HIGH\n");
    //     // // gpio_reset_pin(SPI_CS);
    //     // // gpio_set_direction(SPI_CS, GPIO_MODE_OUTPUT);
    //     gpio_set_level(SPI_CS, 1);
    //     printf("SS pin state after setting HIGH: %d\n", gpio_get_level(SPI_CS));

    //     esp_err_t ret = spi_device_transmit(spi, &trans);

    //     // printf("Setting SS LOW\n");
    //     gpio_set_level(SPI_CS, 0);
    //     printf("SS pin state after setting LOW: %d\n", gpio_get_level(SPI_CS));

    //     if (ret == ESP_OK)
    //     {
    //         printf("SPI Exchange: Sent %d bytes, Received %d bytes\n", BUFFER_SIZE, BUFFER_SIZE);
    //         printf("Send Data: { ");
    //         for (int i = 0; i < BUFFER_SIZE; i++)
    //         {
    //             printf("0x%02X%s", tx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
    //         }
    //         printf("}\n");
    //         printf("Received Data: { ");
    //         for (int i = 0; i < BUFFER_SIZE; i++)
    //         {
    //             printf("0x%02X%s", rx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
    //         }
    //         printf("}\n");
    //     }
    //     else
    //     {
    //         printf("SPI transaction failed: %d\n", ret);
    //     }

    //     // Wait before next transaction
    //     vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay
    // }
}

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>
// #include "driver/spi_master.h"
// #include "driver/gpio.h"
// #include "esp_err.h"

// #define SPI_MOSI 18 // Connected to SDI pin of PIC18F (RC5)
// #define SPI_MISO 19 // Connected to SDO pin of PIC18F (RC6)
// #define SPI_SCLK 20 // Connected to SCK pin of PIC18F (RC4)
// #define SPI_CS 21   // Connected to SS pin of PIC18F (RA6)

// spi_device_handle_t spi;

// void spi_master_init()
// {
//     spi_bus_config_t buscfg = {
//         .mosi_io_num = SPI_MOSI,
//         .miso_io_num = SPI_MISO,
//         .sclk_io_num = SPI_SCLK,

//         .quadwp_io_num = -1,
//         .quadhd_io_num = -1};

//     spi_device_interface_config_t devcfg = {
//         .clock_speed_hz = 100000, // 1MHz SPI clock
//         .mode = 1,
//         .spics_io_num = SPI_CS,
//         .queue_size = 1};

//     // Initialize SPI bus
//     esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to initialize SPI bus: %d\n", ret);
//     }

//     // Attach device to SPI bus
//     ret = spi_bus_add_device(SPI2_HOST, &devcfg, &spi);
//     if (ret != ESP_OK)
//     {
//         printf("Failed to add SPI device: %d\n", ret);
//     }
// }

// void spi_send_receive(uint8_t *tx_data, size_t length, uint8_t *rx_data)
// {
//     spi_transaction_t trans = {
//         .length = length * 8, // Length in bits
//         .tx_buffer = tx_data, // Data to send
//         .rx_buffer = rx_data  // Buffer to receive data
//     };

//     // Transmit the data
//     esp_err_t ret = spi_device_transmit(spi, &trans);
//     if (ret != ESP_OK)
//     {
//         printf("SPI transmission failed: %d\n", ret);
//     }
// }

// uint8_t *spi_bytes_exchange(uint8_t *tx_data, size_t length)
// {
//     if (length == 0 || length > 256) // Beperkingen instellen
//     {
//         printf("SPI Exchange: Ongeldige lengte (%d)\n", (int)length);
//         return NULL;
//     }

//     uint8_t *rx_data = (uint8_t *)malloc(length); // Dynamisch buffer aanmaken
//     if (!rx_data)
//     {
//         printf("SPI Exchange: Geheugenallocatie mislukt\n");
//         return NULL;
//     }
//     memset(rx_data, 0, length); // Buffer leegmaken

//     spi_send_receive(tx_data, length, rx_data);

//     return rx_data; // Caller moet `free(rx_data)` uitvoeren
// }

// void app_main()
// {
//     // spi_master_init();

//     // vTaskDelay(pdMS_TO_TICKS(1000)); // Wait for slave to boot and prep

//     // // Step 1: Send 3 dummy bytes
//     // uint8_t dummy_tx = 0x00;
//     // uint8_t dummy_rx = 0;

//     // for (int i = 0; i < 3; i++)
//     // {
//     //     spi_transaction_t dummy_trans = {
//     //         .length = 8,
//     //         .tx_buffer = &dummy_tx,
//     //         .rx_buffer = &dummy_rx};

//     //     esp_err_t ret = spi_device_transmit(spi, &dummy_trans);
//     //     if (ret == ESP_OK)
//     //     {
//     //         printf("Dummy %d: Sent 0x%02X, Received 0x%02X\n", i + 1, dummy_tx, dummy_rx);
//     //     }
//     //     else
//     //     {
//     //         printf("Dummy %d failed: %d\n", i + 1, ret);
//     //     }
//     //     // vTaskDelay(pdMS_TO_TICKS(1000));
//     // }

//     // // Step 2: Send actual buffer one byte at a time
//     // uint8_t tx_buffer[] = {0xA1, 0xB2, 0xC3, 0xD4, 0xE5};
//     // uint8_t rx_byte = 0;
//     // const int buffer_len = sizeof(tx_buffer) / sizeof(tx_buffer[0]);

//     // for (int i = 0; i < buffer_len; i++)
//     // {
//     //     spi_transaction_t trans = {
//     //         .length = 8,
//     //         .tx_buffer = &tx_buffer[i],
//     //         .rx_buffer = &rx_byte};

//     //     esp_err_t ret = spi_device_transmit(spi, &trans);
//     //     if (ret == ESP_OK)
//     //     {
//     //         printf("Data %d: Sent 0x%02X, Received 0x%02X\n", i + 1, tx_buffer[i], rx_byte);
//     //     }
//     //     else
//     //     {
//     //         printf("Data %d failed: %d\n", i + 1, ret);
//     //     }
//     //     // vTaskDelay(pdMS_TO_TICKS(1000));
//     // }

//     spi_master_init();

//     uint8_t tx_data = 0xAA;
//     uint8_t tx_data_list[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A};
//     uint8_t rx_data = 0;

//     vTaskDelay(pdMS_TO_TICKS(1000));

//     // // Prepare transaction
//     // spi_transaction_t trans = {
//     //     .length = 8, // 8 bits (1 byte)
//     //     .tx_buffer = &tx_data,
//     //     .rx_buffer = &rx_data};

//     // esp_err_t ret = spi_device_transmit(spi, &trans);

//     // if (ret == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     // esp_err_t ret1 = spi_device_transmit(spi, &trans);

//     // if (ret1 == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     // esp_err_t ret2 = spi_device_transmit(spi, &trans);

//     // if (ret2 == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     // esp_err_t ret3 = spi_device_transmit(spi, &trans);

//     // if (ret3 == ESP_OK)
//     // {
//     //     printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//     // }
//     // else
//     // {
//     //     printf("SPI transaction failed: %d\n", ret);
//     // }

//     int count = 0;
//     tx_data = tx_data_list[count];

//     while (1)
//     {
//         // Prepare transaction
//         spi_transaction_t trans = {
//             .length = 8, // 8 bits (1 byte)
//             .tx_buffer = &tx_data,
//             .rx_buffer = &rx_data};

//         esp_err_t ret = spi_device_transmit(spi, &trans);

//         if (ret == ESP_OK)
//         {
//             printf("SPI Exchange: Sent 0x%02X, Received 0x%02X\n", tx_data, rx_data);
//         }
//         else
//         {
//             printf("SPI transaction failed: %d\n", ret);
//         }

//         // Wait before next transaction
//         // vTaskDelay(pdMS_TO_TICKS(1000)); // 1 second delay

//         // if (count++ > 9)
//         // {
//         //     count = 0;
//         // }
//         // count++;
//         // tx_data = tx_data_list[count];
//     }
// }




_____________________________________
Test

esp_err_t spi_exchange(uint8_t *tx_data, uint8_t *rx_data, size_t len)
{
    spi_transaction_t trans = {
        .length = len * 8, // bits
        .tx_buffer = tx_data,
        .rx_buffer = rx_data
    };

    return spi_device_transmit(spi, &trans);
}


void spi_task(void *pvParameters)
{
    uint8_t tx_buf[BUFFER_SIZE];
    uint8_t rx_buf[BUFFER_SIZE];

    while (1)
    {
        // Fill tx_buf with new data or wait for signal/queue...

        esp_err_t ret = spi_exchange_safe(tx_buf, rx_buf, BUFFER_SIZE);
        if (ret == ESP_OK)
        {
            printf("SPI Exchange: Sent %d bytes, Received %d bytes\n", BUFFER_SIZE, BUFFER_SIZE);
            printf("Send Data: { ");
            for (int i = 0; i < BUFFER_SIZE; i++)
            {
                printf("0x%02X%s", tx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
            }
            printf("}\n");
            printf("Received Data: { ");
            for (int i = 0; i < BUFFER_SIZE; i++)
            {
                printf("0x%02X%s", rx_data[i], (i < BUFFER_SIZE - 1) ? ", " : " ");
            }
            printf("}\n");
        }
        else
        {
            printf("SPI transaction failed: %d\n", ret);
        }

        vTaskDelay(pdMS_TO_TICKS(100)); // Adjust frequency
    }
}
